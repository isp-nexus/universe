/**
 * @copyright OpenISP, Inc.
 * @license AGPL-3.0
 * @author Teffen Ellis, et al.
 *
 *   Convert a ShapeFile to GeoJSON.
 */

import { ResourceError } from "@isp.nexus/core/errors"
import { changeFileExtension, CommandHandler, takeReadStreamLines } from "@isp.nexus/sdk"
import {
	csvImportCommand,
	filePathToTableName,
	inferSQLiteFieldTypes,
	pluckCSVColumnHeader,
	splitByFieldSeparator,
	tableSchemaFromInferences,
} from "@isp.nexus/sdk/files/csv"
import { formatSQLite } from "@isp.nexus/sdk/files/sql"
import * as fs from "node:fs/promises"
import { basename } from "node:path"
import { CommandBuilder } from "yargs"

export const command = "infer-csv-schema <csv-file-path> [sql-file-path]"
export const describe = "Infer the SQL schema of a CSV file."

interface CommandArgs {
	"csv-file-path": string
	"field-separator": string
	"sql-file-path"?: string
	"table-name": string
}

export const builder: CommandBuilder<CommandArgs, CommandArgs> = {
	"csv-file-path": {
		describe: "The path to the CSV file.",
		type: "string",
		demandOption: true,
		alias: "i",
	},

	"field-separator": {
		describe: "The character used to separate fields, e.g. ',', '\\t' ';'",
		type: "string",
		default: ",",
		alias: "d",
	},

	"sql-file-path": {
		describe: "The path to the output sql file. Defaults to [csv-file-path].sql",
		normalize: true,
		type: "string",
		alias: "o",
	},

	"table-name": {
		describe: "The name of the table to create in the SQLite database.",
		type: "string",
		alias: "t",
	},
}

export const handler: CommandHandler<CommandArgs> = async (args) => {
	const { csvFilePath, fieldSeparator } = args

	if (fieldSeparator.length !== 1) {
		throw ResourceError.from(400, "Field separator must be a single character.")
	}

	const fieldSeparatorCharacterCode = fieldSeparator.charCodeAt(0)

	const lines: Buffer[] = []

	for await (const line of takeReadStreamLines(csvFilePath, { lineLimit: 5 })) {
		lines.push(line)
	}

	if (lines.length < 2) {
		throw ResourceError.from(400, "CSV file must have at least two lines.")
	}

	const [headerLine, ...sampleLines] = lines
	const columnNames = pluckCSVColumnHeader(headerLine!, fieldSeparatorCharacterCode)
	const sampleFieldsByLine = sampleLines.map((line) => splitByFieldSeparator(line, fieldSeparatorCharacterCode))

	const inferences = inferSQLiteFieldTypes(columnNames, sampleFieldsByLine)
	const tableName = args.tableName || filePathToTableName(csvFilePath)

	let content = `
		-- sqlite

		-- This file was generated by "infer-csv-schema"
		-- ${new Date().toISOString()}
		-- Source: ${csvFilePath}

		${tableSchemaFromInferences(tableName, inferences)}
		`

	if (args.sqlFilePath === "/vsistdout/") {
		process.stdout.write(formatSQLite(content))
		return
	}

	const sqlFilePath = args.sqlFilePath ?? changeFileExtension(csvFilePath, ".schema.sql")

	content +=
		csvImportCommand({
			csvFilePath,
			tableName,
			sqlFilePath: sqlFilePath.startsWith("/") ? sqlFilePath : "./" + basename(sqlFilePath),
			fieldSeparator,
		}) + "\n"

	await fs.writeFile(sqlFilePath, formatSQLite(content))
}
